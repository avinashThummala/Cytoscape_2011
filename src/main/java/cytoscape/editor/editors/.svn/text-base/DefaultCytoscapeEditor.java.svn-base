/* -*-Java-*-
********************************************************************************
*
* File:         DefaultCytoscapeEditor.java
* RCS:          $Header: $
* Description:
* Author:       Allan Kuchinsky
* Created:      Sun Oct 04 05:35:56 2005
* Modified:     Tue Dec 02 18:16:25 2008 (Michael L. Creech) creech@w235krbza760
* Language:     Java
* Package:
/*
 
 Copyright (c) 2006, 2010, The Cytoscape Consortium (www.cytoscape.org)

 This library is free software; you can redistribute it and/or modify it
 under the terms of the GNU Lesser General Public License as published
 by the Free Software Foundation; either version 2.1 of the License, or
 any later version.

 This library is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
 MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
 documentation provided hereunder is on an "as is" basis, and the
 Institute for Systems Biology and the Whitehead Institute
 have no obligations to provide maintenance, support,
 updates, enhancements or modifications.  In no event shall the
 Institute for Systems Biology and the Whitehead Institute
 be liable to any party for direct, indirect, special,
 incidental or consequential damages, including lost profits, arising
 out of the use of this software and its documentation, even if the
 Institute for Systems Biology and the Whitehead Institute
 have been advised of the possibility of such damage.  See
 the GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with this library; if not, write to the Free Software Foundation,
 Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.

*
********************************************************************************
*
* Revisions:
*
* Tue Dec 02 18:15:52 2008 (Michael L. Creech) creech@w235krbza760
*  Added arrowShapeToArrow() and fixed bug where an ArrowShape was
*  being given to CytoShapeIcon constructor.
* Fri Jun 29 09:24:02 2007 (Michael L. Creech) creech@w235krbza760
*  Removed deprecated use in getNodeShape() and getFillColor() in
*  generateNodePaletteEntries().
* Thu May 10 09:37:06 2007 (Michael L. Creech) creech@w235krbza760
*  Updated to use VisualPropertyType versus VizMapUI for Cytoscape 2.5.
* Sun Dec 17 05:36:01 2006 (Michael L. Creech) creech@w235krbza760
*  Added creation of EdgePaletteItemDragCursorSetter and passing it into
*  ShapePalette.addShape() calls.
********************************************************************************
*/

/*
 * TODO To change the template for this generated file go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
package cytoscape.editor.editors;

import giny.view.NodeView;

import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.dnd.DragSource;
import java.awt.dnd.DragSourceDragEvent;
import java.util.Iterator;
import java.util.List;

import javax.swing.ImageIcon;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import cytoscape.Cytoscape;
import cytoscape.editor.CytoscapeEditorFactory;
import cytoscape.editor.CytoscapeEditorManager;
import cytoscape.editor.DragSourceContextCursorSetter;
import cytoscape.editor.ShapePaletteInfo;
import cytoscape.editor.ShapePaletteInfoGenerator;
import cytoscape.editor.event.PaletteNetworkEditEventHandler;
import cytoscape.editor.impl.CytoShapeIcon;
import cytoscape.editor.impl.ShapePalette;
import cytoscape.view.CyNetworkView;
import cytoscape.visual.Arrow;
import cytoscape.visual.ArrowShape;
import cytoscape.visual.EdgeAppearanceCalculator;
import cytoscape.visual.NodeAppearanceCalculator;
import cytoscape.visual.NodeShape;
import cytoscape.visual.VisualPropertyType;
import ding.view.DGraphView;


/**
 * /** An example editor that extends the basic Cytoscape editor and is based
 * upon a drag-and-drop and palette framework into which developers plug in
 * semantics. The framework consists of
 * <ul>
 * <li> a palette, from which the user drags and drops shapes onto the canvas
 * <li> an extensible shape class for the palette,
 * <li> a drawing canvas upon which shapes are dropped, and
 * <li> event handlers which respond to drop events generated by the canvas.
 * </ul>
 * <p>
 * The dropping of shapes onto the canvas results in the addition of nodes and
 * edges to the current Cytoscape network, as defined by the behavior of the
 * event handler that responds to the drop events.
 * <p>
 *
 *
 * @author Allan Kuchinsky
 * @version 1.0
 * @see PaletteNetworkEditEventHandler
 *
 */
public class DefaultCytoscapeEditor extends BasicCytoscapeEditor implements ChangeListener {

	/**
	 * main data structures for all node and edge attributes
	 */
	public static cytoscape.data.CyAttributes nodeAttribs = Cytoscape.getNodeAttributes();

	/**
	 * 
	 */
	public static cytoscape.data.CyAttributes edgeAttribs = Cytoscape.getEdgeAttributes();
	private ShapePalette shapePalette;

	// MLC 12/16/06 BEGIN:
	// Determine how edge palette items show up during a drag op:
	private DragSourceContextCursorSetter _edgeCursorSetter = new EdgePaletteItemDragCursorSetter();

	// MLC 12/16/06 END.
	/**
	 *
	 */
	public DefaultCytoscapeEditor() {
		super();
	}

	// MLC 12/02/06 BEGIN:
	/**
	     * specialized initialization code for editor, called by
	     * CytoscapeEditorManager when a new editor is built.
	     * draws shapes on the palette, based upon the visual style
	     *
	     * @param args
	     *            an arbitrary list of arguments passed to initialization
	     *            routine. Not used in this editor
	     */
	public void initializeControls(List args) {
		shapePalette = CytoscapeEditorManager.getCurrentShapePalette();
		shapePalette.clear();
		generatePaletteEntries();
		shapePalette.showPalette();
		super.initializeControls(null);
	}

	protected void generatePaletteEntries() {
		CytoscapeEditorManager.log("generating palette entries for controlling attributes "
		                           + getControllingNodeAttribute() + " and "
		                           + getControllingEdgeAttribute());
		CytoscapeEditorManager.log("for editor " + this);
		generateEdgePaletteEntries(getControllingEdgeAttribute());
		generateNodePaletteEntries(getControllingNodeAttribute());
		generateNetworkPaletteEntries(getControllingNetworkAttribute());
	}

	protected void generateEdgePaletteEntries(String controllingAttribute) {
		EdgeAppearanceCalculator eac = Cytoscape.getVisualMappingManager().getVisualStyle()
		                                        .getEdgeAppearanceCalculator();

		if (eac == null) {
			return;
		}

		// CytoscapeEditorManager.log("Got edgeAppearanceCalculator: " + eac);		
		ShapePaletteInfoGenerator palGen = CytoscapeEditorFactory.INSTANCE
		                                                                                                                                                       .createShapePaletteInfoGenerator();

		VisualPropertyType[] calcsToUse = new VisualPropertyType [] { VisualPropertyType.EDGE_TGTARROW_SHAPE };

		Iterator<ShapePaletteInfo> spEntries = palGen.buildShapePaletteInfo(eac, calcsToUse,
		                                                                    controllingAttribute,
		                                                                    this, null);
		
		CytoscapeEditorManager.log("any edge types for shape palette? " + spEntries.hasNext());

		if (!spEntries.hasNext()) {
			shapePalette.addShape(controllingAttribute, "DirectedEdge",
					      // MLC 10/24/07:
			                      // new CytoShapeIcon(Arrow.DELTA), "Directed Edge",
					      // MLC 10/24/07:
			                      new CytoShapeIcon(Arrow.NONE), "Add an Edge",
			_edgeCursorSetter);
		} else {
			while (spEntries.hasNext()) {
				ShapePaletteInfo spi = spEntries.next();
				shapePalette.addShape(spi.getControllingAttributeName(), spi.getKey(),
						      // MLC 05/09/07:
				                      // new CytoShapeIcon((Arrow) spi.getValue(VizMapUI.EDGE_TGTARROW)),
						      // MLC 12/02/08 BEGIN:
				                      // new CytoShapeIcon((Arrow) spi.getValue(VisualPropertyType.EDGE_TGTARROW_SHAPE)),
						      new CytoShapeIcon(arrowShapeToArrow((ArrowShape) spi.getValue(VisualPropertyType.EDGE_TGTARROW_SHAPE))),
						      // MLC 12/02/08 END.
				                      spi.getKey(), // MLC 12/16/06:
				_edgeCursorSetter);
			}
		}
	}

    // MLC 12/02/08 BEGIN:
    protected Arrow arrowShapeToArrow(ArrowShape as) {
        if (as == ArrowShape.ARROW) {
            return Arrow.ARROW;
        } else if (as == ArrowShape.CIRCLE) {
            return Arrow.CIRCLE;
        } else if (as == ArrowShape.DELTA) {
            return Arrow.DELTA;
        } else if (as == ArrowShape.DIAMOND) {
            return Arrow.DIAMOND;
        } else if (as == ArrowShape.NONE) {
            return Arrow.NONE;
        } else if (as == ArrowShape.T) {
            return Arrow.T;
        }

        return null;
    }
    // MLC 12/02/08 END

	protected void generateNodePaletteEntries(String controllingAttribute) {
		NodeAppearanceCalculator nac = Cytoscape.getVisualMappingManager().getVisualStyle()
		                                        .getNodeAppearanceCalculator();

		if (nac == null) {
			return;
		}

		ShapePaletteInfoGenerator palGen = CytoscapeEditorFactory.INSTANCE
		                                                                                                                                                                                          .createShapePaletteInfoGenerator();
		VisualPropertyType[] calcsToUse = new VisualPropertyType[] { VisualPropertyType.NODE_FILL_COLOR, VisualPropertyType.NODE_SHAPE, VisualPropertyType.NODE_SIZE };
		Iterator<ShapePaletteInfo> spEntries = palGen.buildShapePaletteInfo(nac, calcsToUse,
		                                                                    controllingAttribute,
		                                                                    this, null);

		if (!spEntries.hasNext()) {
			shapePalette.addShape(controllingAttribute, "DefaultNode",
					      // MLC 06/30/07 BEGIN:
			                      // new CytoShapeIcon(nac.getDefaultAppearance().getNodeShape(),
					      //                   nac.getDefaultAppearance().getFillColor()),
			                      new CytoShapeIcon((NodeShape)(nac.getDefaultAppearance().get (VisualPropertyType.NODE_SHAPE)),
			                                        (Color)(nac.getDefaultAppearance().get (VisualPropertyType.NODE_FILL_COLOR))),
								// MLC 06/30/07 END.
								"Add a Node", // MLC 12/16/06:
								null);
		} else {
			while (spEntries.hasNext()) {
				ShapePaletteInfo spi = spEntries.next();

				Color nodeColor = (Color) spi.getValue(VisualPropertyType.NODE_FILL_COLOR);
				NodeShape nodeShape = (NodeShape) spi.getValue(VisualPropertyType.NODE_SHAPE);
				int nodeSize = (int) ((Double) spi.getValue(VisualPropertyType.NODE_SIZE)).longValue();
				// MLC 05/09/07 END.
				shapePalette.addShape(spi.getControllingAttributeName(), spi.getKey(),
				                      new CytoShapeIcon(nodeShape, nodeColor,
				                                        new Dimension(nodeSize, nodeSize)),
				                      spi.getKey(), // MLC 12/16/06:
				null);
			}
		}
	}


	protected void generateNetworkPaletteEntries(String controllingAttribute) {
		
		javax.swing.ImageIcon icon = new ImageIcon(getClass().getResource("/network.png"));
		
		shapePalette.addShape(controllingAttribute, "DefaultNestedNetwork",
			                      new CytoShapeIcon(icon.getImage()),
								"Add a Nested Network",
								null);
	}

	
	
	protected ShapePalette getShapePalette() {
		return shapePalette;
	}

	/**
	 * sets controls invisible when editor type is switched
	 *
	 * @param args
	 *            args an arbitrary list of arguments (not used in this editor)
	 */
	public void disableControls(List args) {
		// super.disableControls(args);
		if (shapePalette != null) {
			shapePalette.setVisible(false);
		}
	}

	/**
	 * sets controls visible when editor type is switched back to this editor
	 *
	 * @param args
	 *            args an arbitrary list of arguments (not used in this editor) *
	 */
	public void enableControls(List args) {
		// super.enableControls(args);
		shapePalette.showPalette();
		shapePalette.setVisible(true);
	}

	/**
	 * redraw palette when a shape, color, or arrow mapping changes
	 *
	 * @param e
	 */
	public void stateChanged(ChangeEvent e) {
		initializeControls(null);
	}

	// MLC 12/16/06 BEGIN:
	// give sublcasses access to the default setter for edge palette entries:
	protected DragSourceContextCursorSetter getDefaultEdgePaletteItemDragCursorSetter() {
		return _edgeCursorSetter;
	}

	// A CursorSetter that says it's only ok to drop when we are on a Node:
	private class EdgePaletteItemDragCursorSetter implements DragSourceContextCursorSetter {
		public Cursor computeCursor(CyNetworkView netView, Point netViewLoc,
		                            DragSourceDragEvent dsde) {
			// Now check if we are on a NodeView?
			NodeView nv = ((DGraphView) netView).getPickedNodeView(netViewLoc);

			if (nv != null) {
				return DragSource.DefaultCopyDrop;
			}

			return DragSource.DefaultCopyNoDrop;
		}
	}

	// MLC 12/16/06 END.
}
